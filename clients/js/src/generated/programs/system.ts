/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
    assertIsInstructionWithAccounts,
    containsBytes,
    getU32Encoder,
    SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_INSTRUCTION,
    SOLANA_ERROR__PROGRAM_CLIENTS__UNRECOGNIZED_INSTRUCTION_TYPE,
    SolanaError,
    type Address,
    type ClientWithPayer,
    type ClientWithRpc,
    type ClientWithTransactionPlanning,
    type ClientWithTransactionSending,
    type GetAccountInfoApi,
    type GetMultipleAccountsApi,
    type Instruction,
    type InstructionWithData,
    type ReadonlyUint8Array,
} from '@solana/kit';
import {
    addSelfFetchFunctions,
    addSelfPlanAndSendFunctions,
    type SelfFetchFunctions,
    type SelfPlanAndSendFunctions,
} from '@solana/kit/program-client-core';
import { getNonceCodec, type Nonce, type NonceArgs } from '../accounts';
import {
    getAdvanceNonceAccountInstruction,
    getAllocateInstruction,
    getAllocateWithSeedInstruction,
    getAssignInstruction,
    getAssignWithSeedInstruction,
    getAuthorizeNonceAccountInstruction,
    getCreateAccountInstruction,
    getCreateAccountWithSeedInstruction,
    getInitializeNonceAccountInstruction,
    getTransferSolInstruction,
    getTransferSolWithSeedInstruction,
    getUpgradeNonceAccountInstruction,
    getWithdrawNonceAccountInstruction,
    parseAdvanceNonceAccountInstruction,
    parseAllocateInstruction,
    parseAllocateWithSeedInstruction,
    parseAssignInstruction,
    parseAssignWithSeedInstruction,
    parseAuthorizeNonceAccountInstruction,
    parseCreateAccountInstruction,
    parseCreateAccountWithSeedInstruction,
    parseInitializeNonceAccountInstruction,
    parseTransferSolInstruction,
    parseTransferSolWithSeedInstruction,
    parseUpgradeNonceAccountInstruction,
    parseWithdrawNonceAccountInstruction,
    type AdvanceNonceAccountInput,
    type AllocateInput,
    type AllocateWithSeedInput,
    type AssignInput,
    type AssignWithSeedInput,
    type AuthorizeNonceAccountInput,
    type CreateAccountInput,
    type CreateAccountWithSeedInput,
    type InitializeNonceAccountInput,
    type ParsedAdvanceNonceAccountInstruction,
    type ParsedAllocateInstruction,
    type ParsedAllocateWithSeedInstruction,
    type ParsedAssignInstruction,
    type ParsedAssignWithSeedInstruction,
    type ParsedAuthorizeNonceAccountInstruction,
    type ParsedCreateAccountInstruction,
    type ParsedCreateAccountWithSeedInstruction,
    type ParsedInitializeNonceAccountInstruction,
    type ParsedTransferSolInstruction,
    type ParsedTransferSolWithSeedInstruction,
    type ParsedUpgradeNonceAccountInstruction,
    type ParsedWithdrawNonceAccountInstruction,
    type TransferSolInput,
    type TransferSolWithSeedInput,
    type UpgradeNonceAccountInput,
    type WithdrawNonceAccountInput,
} from '../instructions';

export const SYSTEM_PROGRAM_ADDRESS = '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;

export enum SystemAccount {
    Nonce,
}

export enum SystemInstruction {
    CreateAccount,
    Assign,
    TransferSol,
    CreateAccountWithSeed,
    AdvanceNonceAccount,
    WithdrawNonceAccount,
    InitializeNonceAccount,
    AuthorizeNonceAccount,
    Allocate,
    AllocateWithSeed,
    AssignWithSeed,
    TransferSolWithSeed,
    UpgradeNonceAccount,
}

export function identifySystemInstruction(
    instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): SystemInstruction {
    const data = 'data' in instruction ? instruction.data : instruction;
    if (containsBytes(data, getU32Encoder().encode(0), 0)) {
        return SystemInstruction.CreateAccount;
    }
    if (containsBytes(data, getU32Encoder().encode(1), 0)) {
        return SystemInstruction.Assign;
    }
    if (containsBytes(data, getU32Encoder().encode(2), 0)) {
        return SystemInstruction.TransferSol;
    }
    if (containsBytes(data, getU32Encoder().encode(3), 0)) {
        return SystemInstruction.CreateAccountWithSeed;
    }
    if (containsBytes(data, getU32Encoder().encode(4), 0)) {
        return SystemInstruction.AdvanceNonceAccount;
    }
    if (containsBytes(data, getU32Encoder().encode(5), 0)) {
        return SystemInstruction.WithdrawNonceAccount;
    }
    if (containsBytes(data, getU32Encoder().encode(6), 0)) {
        return SystemInstruction.InitializeNonceAccount;
    }
    if (containsBytes(data, getU32Encoder().encode(7), 0)) {
        return SystemInstruction.AuthorizeNonceAccount;
    }
    if (containsBytes(data, getU32Encoder().encode(8), 0)) {
        return SystemInstruction.Allocate;
    }
    if (containsBytes(data, getU32Encoder().encode(9), 0)) {
        return SystemInstruction.AllocateWithSeed;
    }
    if (containsBytes(data, getU32Encoder().encode(10), 0)) {
        return SystemInstruction.AssignWithSeed;
    }
    if (containsBytes(data, getU32Encoder().encode(11), 0)) {
        return SystemInstruction.TransferSolWithSeed;
    }
    if (containsBytes(data, getU32Encoder().encode(12), 0)) {
        return SystemInstruction.UpgradeNonceAccount;
    }
    throw new SolanaError(SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_INSTRUCTION, {
        instructionData: data,
        programName: 'system',
    });
}

export type ParsedSystemInstruction<TProgram extends string = '11111111111111111111111111111111'> =
    | ({ instructionType: SystemInstruction.CreateAccount } & ParsedCreateAccountInstruction<TProgram>)
    | ({ instructionType: SystemInstruction.Assign } & ParsedAssignInstruction<TProgram>)
    | ({ instructionType: SystemInstruction.TransferSol } & ParsedTransferSolInstruction<TProgram>)
    | ({ instructionType: SystemInstruction.CreateAccountWithSeed } & ParsedCreateAccountWithSeedInstruction<TProgram>)
    | ({ instructionType: SystemInstruction.AdvanceNonceAccount } & ParsedAdvanceNonceAccountInstruction<TProgram>)
    | ({ instructionType: SystemInstruction.WithdrawNonceAccount } & ParsedWithdrawNonceAccountInstruction<TProgram>)
    | ({
          instructionType: SystemInstruction.InitializeNonceAccount;
      } & ParsedInitializeNonceAccountInstruction<TProgram>)
    | ({ instructionType: SystemInstruction.AuthorizeNonceAccount } & ParsedAuthorizeNonceAccountInstruction<TProgram>)
    | ({ instructionType: SystemInstruction.Allocate } & ParsedAllocateInstruction<TProgram>)
    | ({ instructionType: SystemInstruction.AllocateWithSeed } & ParsedAllocateWithSeedInstruction<TProgram>)
    | ({ instructionType: SystemInstruction.AssignWithSeed } & ParsedAssignWithSeedInstruction<TProgram>)
    | ({ instructionType: SystemInstruction.TransferSolWithSeed } & ParsedTransferSolWithSeedInstruction<TProgram>)
    | ({ instructionType: SystemInstruction.UpgradeNonceAccount } & ParsedUpgradeNonceAccountInstruction<TProgram>);

export function parseSystemInstruction<TProgram extends string>(
    instruction: Instruction<TProgram> & InstructionWithData<ReadonlyUint8Array>,
): ParsedSystemInstruction<TProgram> {
    const instructionType = identifySystemInstruction(instruction);
    switch (instructionType) {
        case SystemInstruction.CreateAccount: {
            assertIsInstructionWithAccounts(instruction);
            return { instructionType: SystemInstruction.CreateAccount, ...parseCreateAccountInstruction(instruction) };
        }
        case SystemInstruction.Assign: {
            assertIsInstructionWithAccounts(instruction);
            return { instructionType: SystemInstruction.Assign, ...parseAssignInstruction(instruction) };
        }
        case SystemInstruction.TransferSol: {
            assertIsInstructionWithAccounts(instruction);
            return { instructionType: SystemInstruction.TransferSol, ...parseTransferSolInstruction(instruction) };
        }
        case SystemInstruction.CreateAccountWithSeed: {
            assertIsInstructionWithAccounts(instruction);
            return {
                instructionType: SystemInstruction.CreateAccountWithSeed,
                ...parseCreateAccountWithSeedInstruction(instruction),
            };
        }
        case SystemInstruction.AdvanceNonceAccount: {
            assertIsInstructionWithAccounts(instruction);
            return {
                instructionType: SystemInstruction.AdvanceNonceAccount,
                ...parseAdvanceNonceAccountInstruction(instruction),
            };
        }
        case SystemInstruction.WithdrawNonceAccount: {
            assertIsInstructionWithAccounts(instruction);
            return {
                instructionType: SystemInstruction.WithdrawNonceAccount,
                ...parseWithdrawNonceAccountInstruction(instruction),
            };
        }
        case SystemInstruction.InitializeNonceAccount: {
            assertIsInstructionWithAccounts(instruction);
            return {
                instructionType: SystemInstruction.InitializeNonceAccount,
                ...parseInitializeNonceAccountInstruction(instruction),
            };
        }
        case SystemInstruction.AuthorizeNonceAccount: {
            assertIsInstructionWithAccounts(instruction);
            return {
                instructionType: SystemInstruction.AuthorizeNonceAccount,
                ...parseAuthorizeNonceAccountInstruction(instruction),
            };
        }
        case SystemInstruction.Allocate: {
            assertIsInstructionWithAccounts(instruction);
            return { instructionType: SystemInstruction.Allocate, ...parseAllocateInstruction(instruction) };
        }
        case SystemInstruction.AllocateWithSeed: {
            assertIsInstructionWithAccounts(instruction);
            return {
                instructionType: SystemInstruction.AllocateWithSeed,
                ...parseAllocateWithSeedInstruction(instruction),
            };
        }
        case SystemInstruction.AssignWithSeed: {
            assertIsInstructionWithAccounts(instruction);
            return {
                instructionType: SystemInstruction.AssignWithSeed,
                ...parseAssignWithSeedInstruction(instruction),
            };
        }
        case SystemInstruction.TransferSolWithSeed: {
            assertIsInstructionWithAccounts(instruction);
            return {
                instructionType: SystemInstruction.TransferSolWithSeed,
                ...parseTransferSolWithSeedInstruction(instruction),
            };
        }
        case SystemInstruction.UpgradeNonceAccount: {
            assertIsInstructionWithAccounts(instruction);
            return {
                instructionType: SystemInstruction.UpgradeNonceAccount,
                ...parseUpgradeNonceAccountInstruction(instruction),
            };
        }
        default:
            throw new SolanaError(SOLANA_ERROR__PROGRAM_CLIENTS__UNRECOGNIZED_INSTRUCTION_TYPE, {
                instructionType: instructionType as string,
                programName: 'system',
            });
    }
}

export type SystemPlugin = { accounts: SystemPluginAccounts; instructions: SystemPluginInstructions };

export type SystemPluginAccounts = { nonce: ReturnType<typeof getNonceCodec> & SelfFetchFunctions<NonceArgs, Nonce> };

export type SystemPluginInstructions = {
    createAccount: (
        input: MakeOptional<CreateAccountInput, 'payer'>,
    ) => ReturnType<typeof getCreateAccountInstruction> & SelfPlanAndSendFunctions;
    assign: (input: AssignInput) => ReturnType<typeof getAssignInstruction> & SelfPlanAndSendFunctions;
    transferSol: (input: TransferSolInput) => ReturnType<typeof getTransferSolInstruction> & SelfPlanAndSendFunctions;
    createAccountWithSeed: (
        input: MakeOptional<CreateAccountWithSeedInput, 'payer'>,
    ) => ReturnType<typeof getCreateAccountWithSeedInstruction> & SelfPlanAndSendFunctions;
    advanceNonceAccount: (
        input: AdvanceNonceAccountInput,
    ) => ReturnType<typeof getAdvanceNonceAccountInstruction> & SelfPlanAndSendFunctions;
    withdrawNonceAccount: (
        input: WithdrawNonceAccountInput,
    ) => ReturnType<typeof getWithdrawNonceAccountInstruction> & SelfPlanAndSendFunctions;
    initializeNonceAccount: (
        input: InitializeNonceAccountInput,
    ) => ReturnType<typeof getInitializeNonceAccountInstruction> & SelfPlanAndSendFunctions;
    authorizeNonceAccount: (
        input: AuthorizeNonceAccountInput,
    ) => ReturnType<typeof getAuthorizeNonceAccountInstruction> & SelfPlanAndSendFunctions;
    allocate: (input: AllocateInput) => ReturnType<typeof getAllocateInstruction> & SelfPlanAndSendFunctions;
    allocateWithSeed: (
        input: AllocateWithSeedInput,
    ) => ReturnType<typeof getAllocateWithSeedInstruction> & SelfPlanAndSendFunctions;
    assignWithSeed: (
        input: AssignWithSeedInput,
    ) => ReturnType<typeof getAssignWithSeedInstruction> & SelfPlanAndSendFunctions;
    transferSolWithSeed: (
        input: TransferSolWithSeedInput,
    ) => ReturnType<typeof getTransferSolWithSeedInstruction> & SelfPlanAndSendFunctions;
    upgradeNonceAccount: (
        input: UpgradeNonceAccountInput,
    ) => ReturnType<typeof getUpgradeNonceAccountInstruction> & SelfPlanAndSendFunctions;
};

export type SystemPluginRequirements = ClientWithRpc<GetAccountInfoApi & GetMultipleAccountsApi> &
    ClientWithPayer &
    ClientWithTransactionPlanning &
    ClientWithTransactionSending;

export function systemProgram() {
    return <T extends SystemPluginRequirements>(client: T) => {
        return {
            ...client,
            system: <SystemPlugin>{
                accounts: { nonce: addSelfFetchFunctions(client, getNonceCodec()) },
                instructions: {
                    createAccount: input =>
                        addSelfPlanAndSendFunctions(
                            client,
                            getCreateAccountInstruction({ ...input, payer: input.payer ?? client.payer }),
                        ),
                    assign: input => addSelfPlanAndSendFunctions(client, getAssignInstruction(input)),
                    transferSol: input => addSelfPlanAndSendFunctions(client, getTransferSolInstruction(input)),
                    createAccountWithSeed: input =>
                        addSelfPlanAndSendFunctions(
                            client,
                            getCreateAccountWithSeedInstruction({ ...input, payer: input.payer ?? client.payer }),
                        ),
                    advanceNonceAccount: input =>
                        addSelfPlanAndSendFunctions(client, getAdvanceNonceAccountInstruction(input)),
                    withdrawNonceAccount: input =>
                        addSelfPlanAndSendFunctions(client, getWithdrawNonceAccountInstruction(input)),
                    initializeNonceAccount: input =>
                        addSelfPlanAndSendFunctions(client, getInitializeNonceAccountInstruction(input)),
                    authorizeNonceAccount: input =>
                        addSelfPlanAndSendFunctions(client, getAuthorizeNonceAccountInstruction(input)),
                    allocate: input => addSelfPlanAndSendFunctions(client, getAllocateInstruction(input)),
                    allocateWithSeed: input =>
                        addSelfPlanAndSendFunctions(client, getAllocateWithSeedInstruction(input)),
                    assignWithSeed: input => addSelfPlanAndSendFunctions(client, getAssignWithSeedInstruction(input)),
                    transferSolWithSeed: input =>
                        addSelfPlanAndSendFunctions(client, getTransferSolWithSeedInstruction(input)),
                    upgradeNonceAccount: input =>
                        addSelfPlanAndSendFunctions(client, getUpgradeNonceAccountInstruction(input)),
                },
            },
        };
    };
}

type MakeOptional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
